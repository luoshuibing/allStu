# 不屈日记
##  场景题

### 订单到期关闭如何实现

在电商、支付等系统中，一般都是先创建订单，再给用户一定的时间进行支付，如果没有按时支付的话，就需要把之前的订单取消掉。这种类似的场景有很多，还有比如到期自动自动收货、超时自动退款、下单后自动发送短信等等都是类似的业务问题。

订单的到期关闭的实现有很多方式。
* 被动关闭（不推荐）

在解决这类问题的时候，有一种比较简单的方式，那就是通过业务上的被动方式来进行关单操作。

简单点说，就是订单创建好了以后，我们系统上不做主动关单，什么时候用户来访问这个订单了，再去判断时间是不是超过了过期时间，如果过了时间那就进行关单操作，然后再提示用户。
这种操作是最简单的，基本不需要开发定时关闭的功能，但是他的缺点也很明显，那就是如果用户一直不来查看这个订单，那么就会有很多脏数据冗余在数据库中一直无法被关单。

还有一个缺点，那就是需要在用户的查询过程中进行写的操作，一般写操作都会比读操作耗时更长，而且有失败的可能，一旦关单失败，就会导致系统处理起来比较复杂。

* 定时任务

定时任务定时扫描所有到期的订单，然后执行关单动作。
但是有以下几个问题。
1. 时间不精确。一般定时任务基于固定的频率、按照时间定时执行的，那么就可能会发生很多订单已经到了超时时间，但是定时任务的调度时间还没到，那么就会导致这些订单的实际关闭时间要比应该关闭的时间晚一些。
2. 无法处理大量订单量。定时任务的方式是会把本来比较分散的关闭时间集中到任务调度的那一段时间，如果订单量比较大的话，那么就可能导致执行时间很长，整个任务的时间超长，订单被扫描的时间可能就很晚，那么就会导致关闭时间更晚。
3. 对数据库造成压力。定时任务集中扫表，这会使得数据库IO在短时间内被大量占用和消耗，如果没有做好隔离，并且业务量比较大的话，就可能会影响线上的正常业务。
4. 分库分表问题。订单系统，一旦订单量大就可能会考虑分库分表，在分库分表中进行全表扫描，这是一个极不推荐的方案。

* DelayQueue（不推荐，基于内存，无法持久化）

使用DelayQueue实现超时关单的方案，实现起来简单，不需要依赖第三方的框架和类库，JDK原生就支持。

当然这个方案，如果订单量过大，能导致OOM的问题。DelayQueue是基于JVM内存，一旦机器重启，数据就丢失。基于JDK的DelayQueue方案只适合单机。

* 时间轮（不推荐，基于内存，无法持久化）

因为DelayQueue插入和删除操作的平均时间复杂度-O(nlog(n)),虽然已经挺好，但是时间轮的方案可以插入和删除操作的时间复杂度都降为O(1).

基于Netty的HashedWheelTimer可以帮助我们快速的实现一个时间轮，这种方式和DelayQueue类似，缺点都是基于内存、集群扩展麻烦、内存有限制等等。

* kafka（MQ方案不推荐，大量无效调度）

kafka内部有很多延时性操作，如延时生产，延时拉取，延时数据删除等，这些延时功能由内部的延时操作管理器来做专门的处理，其底层是采用时间轮实现的。

为了解决有一些时间跨度大的延时任务，kafka还引入了层级时间轮，能更好控制时间力度。

kafka中的时间轮，在实现方式上优点复杂，需要依赖kafka，但是他的稳定性和性能都要更高一些，而且适合用在分布式场景中。

* RocketMQ延迟消息（MQ方案不推荐，大量无效调度）

RocketMQ支持延迟消息，只是支持固定时长的延迟消息1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h

* RabbitMQ死信队列（MQ方案不推荐，大量无效调度）

当RabbitMQ中的一条正常的消息，因为过了存活时间（TTL过期）、队列长度超限、被消费者拒绝等原因无法被消费时，就会变成Dead Message。

基于RabbitMQ的死信队列，可以实现延迟消息，非常灵活的实现定时关单，并且借助RabbitMQ的集群扩展性，可以实现高可用，以及处理大并发。缺点是可能消息阻塞。

* Redis过期监听（不推荐，容易丢消息）

redis加入配置过期监听，实现监听器就可以监听key的过期消息。redis并不保证key在过期的时候就能被立即删除，更不保证这个消息能被立即发出。所以，消息延迟是必然存在的。


* Redis的ZSet（不推荐，可能会重复消费）

订单超时时间的时间戳（下单时间+超时时长）与订单号分别设置为 score 和 member。

使用redis zset来实现订单关闭的功能的优点是可以借助redis的持久化、高可用机制。避免数据丢失。但是这个方案也有缺点，那就是在高并发场景中，有可能有多个消费者同时获取到同一个订单号，一般采用加分布式锁解决，这样做也会降低吞吐量。

* Redisson（推荐，可以用）

Redission定义了分布式延迟队列RDelayedQueue，这是一种基于我们前面介绍过的zset结构实现的延时队列，它允许以指定的延时时长将元素放到目标队列中。

基于Redission的实现方式，是可以解决基于zset方案中的并发重复问题，而且还能实现方式也比较简单，稳定性、性能都比较高。


##  线上问题排查
##  项目难点&亮点
##  大厂实践
##  Java基础
##  集合类
##  Java并发
##  Jvm
##  Spring
##  MySQL
##  MyBatis
##  Tomcat
##  Netty
##  微服务
##  分布式
##  Redis
##  Dubbo
##  Kafka
##  RocketMQ
##  RabbitMQ
##  配置中心
##  ElasticSearch
##  Zookeeper
##  高性能
##  高可用
##  高并发
##  本地缓存
##  分库分表
##  定时任务
##  文件处理
##  DDD
##  Maven&Git
##  IDEA
##  日志
##  设计模式
##  单元测试
##  云计算
##  计算机网络
##  网络安全
##  操作系统
##  数据结构
##  容器
##  架构设计
##  编程题
##  智商题
##  非技术问题
##  其他
##  其他专属内容
##  面经实战