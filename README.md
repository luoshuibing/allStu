# 不屈日记
##  场景题

### 订单到期关闭如何实现

在电商、支付等系统中，一般都是先创建订单，再给用户一定的时间进行支付，如果没有按时支付的话，就需要把之前的订单取消掉。这种类似的场景有很多，还有比如到期自动自动收货、超时自动退款、下单后自动发送短信等等都是类似的业务问题。

订单的到期关闭的实现有很多方式。
* 被动关闭（不推荐）

在解决这类问题的时候，有一种比较简单的方式，那就是通过业务上的被动方式来进行关单操作。

简单点说，就是订单创建好了以后，我们系统上不做主动关单，什么时候用户来访问这个订单了，再去判断时间是不是超过了过期时间，如果过了时间那就进行关单操作，然后再提示用户。
这种操作是最简单的，基本不需要开发定时关闭的功能，但是他的缺点也很明显，那就是如果用户一直不来查看这个订单，那么就会有很多脏数据冗余在数据库中一直无法被关单。

还有一个缺点，那就是需要在用户的查询过程中进行写的操作，一般写操作都会比读操作耗时更长，而且有失败的可能，一旦关单失败，就会导致系统处理起来比较复杂。

* 定时任务

定时任务定时扫描所有到期的订单，然后执行关单动作。
但是有以下几个问题。
1. 时间不精确。一般定时任务基于固定的频率、按照时间定时执行的，那么就可能会发生很多订单已经到了超时时间，但是定时任务的调度时间还没到，那么就会导致这些订单的实际关闭时间要比应该关闭的时间晚一些。
2. 无法处理大量订单量。定时任务的方式是会把本来比较分散的关闭时间集中到任务调度的那一段时间，如果订单量比较大的话，那么就可能导致执行时间很长，整个任务的时间超长，订单被扫描的时间可能就很晚，那么就会导致关闭时间更晚。
3. 对数据库造成压力。定时任务集中扫表，这会使得数据库IO在短时间内被大量占用和消耗，如果没有做好隔离，并且业务量比较大的话，就可能会影响线上的正常业务。
4. 分库分表问题。订单系统，一旦订单量大就可能会考虑分库分表，在分库分表中进行全表扫描，这是一个极不推荐的方案。

* DelayQueue（不推荐，基于内存，无法持久化）

使用DelayQueue实现超时关单的方案，实现起来简单，不需要依赖第三方的框架和类库，JDK原生就支持。

当然这个方案，如果订单量过大，能导致OOM的问题。DelayQueue是基于JVM内存，一旦机器重启，数据就丢失。基于JDK的DelayQueue方案只适合单机。

* 时间轮（不推荐，基于内存，无法持久化）

因为DelayQueue插入和删除操作的平均时间复杂度-O(nlog(n)),虽然已经挺好，但是时间轮的方案可以插入和删除操作的时间复杂度都降为O(1).

基于Netty的HashedWheelTimer可以帮助我们快速的实现一个时间轮，这种方式和DelayQueue类似，缺点都是基于内存、集群扩展麻烦、内存有限制等等。

* kafka（MQ方案不推荐，大量无效调度）
* RocketMQ延迟消息（MQ方案不推荐，大量无效调度）
* RabbitMQ死信队列（MQ方案不推荐，大量无效调度）
* Redis过期监听（不推荐，容易丢消息）
* Redis的ZSet（不推荐，可能会重复消费）
* Redisson（推荐，可以用）

##  线上问题排查
##  项目难点&亮点
##  大厂实践
##  Java基础
##  集合类
##  Java并发
##  Jvm
##  Spring
##  MySQL
##  MyBatis
##  Tomcat
##  Netty
##  微服务
##  分布式
##  Redis
##  Dubbo
##  Kafka
##  RocketMQ
##  RabbitMQ
##  配置中心
##  ElasticSearch
##  Zookeeper
##  高性能
##  高可用
##  高并发
##  本地缓存
##  分库分表
##  定时任务
##  文件处理
##  DDD
##  Maven&Git
##  IDEA
##  日志
##  设计模式
##  单元测试
##  云计算
##  计算机网络
##  网络安全
##  操作系统
##  数据结构
##  容器
##  架构设计
##  编程题
##  智商题
##  非技术问题
##  其他
##  其他专属内容
##  面经实战